<!doctype html>
<html>
<head>
  <title>JavaScript Basics - 1.2 Basics</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <!-- <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" /> -->
  <link href="jsBasics.css" rel="stylesheet" />

  <link rel="stylesheet" href="highlight/styles/idea.css">
  <script src="highlight/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

</head>
<body>
  <div id="impress">

    <div class="fallback-message">
        <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
        <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
    </div>

    <div class="step"  id="title" data-x="0">
      <img src="js.jpg" alt="" class="fill">
      <h3>JavaScript Basics</h3>

      <div class="mod-note">
      </div>
    </div>

    <div class="step"  id="1" data-y="2000">
      <h3>Language Properties</h3>
      <ul>
        <li>dynamicly typed</li>
        <li>loose typing</li>
        <li>very small core</li>
        <li>multi-paradigm</li>
        <li>functional, OO, procedural</li>
      </ul>
      <div class="mod-note">
        -
      </div>
    </div>
    <div class="step"  id="2" data-y="4000">
      <h3>Syntax</h3>
      <ul>
        <li>C - Family</li>
        <li>influenced by Java</li>
        <li>Semicolons are optional - ASI</li>
        <li>curly braces are optional</li>
        <li>only few builtin types</li>
      </ul>
      <div class="mod-note">
      </div>
    </div>

    <div class="step"  id="3" data-y="4000" data-x="2000">
      <h3>Syntax: var, loops, branching</h3>
      <pre><code>
var linePlural = ' bottles of beer on the wall',
    lineSingular = ' bottle of beer on the wall',
    bottles, isOneBottle;

for (bottles = 99; bottles > 0; bottles--) {
  isOneBottle = (bottles === 1);
  if (isOneBottle) {
    console.log(bottles + lineSingular);
  } else {
    console.log(bottles + linePlural);
  }
}
      </code></pre>
      <div class="mod-note">
        - keine Typenangabe
        - var kann überall vorkommen, wird gehoisted
        - kein blockscope, auch nicht in for loops
        - Schleifen und Kontrollstrukturen wie in Java
        - switch-case ist mächtig, kann auf allen Werten arbeiten, allerdings kein pattern matching sondern ein === vergleich
      </div>
    </div>

    <div class="step"  id="4" data-y="2000" data-x="2000">
      <h3>Literals</h3>
      <pre><code>
var str = 'a string', number = 42,
    bool = true, nullRef = null, undef
    regex = /foo/gim;
var arr = [1,'2',3], object = {prop: 'value'};
var funcExp = function(){};

function funcStatment(){
  return str.length;
}
      </code></pre>
      <div class="mod-note">

      </div>
    </div>
    <div class="step"  id="5" data-y="0" data-x="2000">
      <h3>Primitives, Wrappers and Autoboxing</h3>
      <pre><code>
var str = 'a string', number = 42,
    bool = true;
var strObj = new String("another string"),
    numObj = new Number(21),
    bool = new Boolean(false);
var nan = NaN, infinity = Infinity;
      </code></pre>
      <div class="mod-note">
        - neben primitiven datentypen gibt es auch objekt-repräsentationen.
        - Vorgreifend: jede funktion kann ein objekt konstruktor sein, aufruf mit new
        - Number, String, Boolean (und Object) sind solche funktionen.
        - Achtung: ohne new funktionieren diese als cast: Konstruktor gibt ein Objekt zurück, Cast liefert ein primitive
        - Achtung: Object delegiert in bestimmten fällen an Number, Boolean und String
      </div>
    </div>
    <div class="step"  id="6" data-y="0" data-x="4000">
      <h3>typeof and types</h3>
      <pre><code>
typeof 1;
typeof 'string';
typeof false;
typeof {};
typeof function(){};
typeof undefined;
typeof null;
typeof [];
typeof new String('string');
      </code></pre>
      <div class="mod-note">
        - JavaSript hat nur wenige Wert Typen. (variablen haben keinen Typ)
        - mit dem typeof operator kann man diesen abfragen.
        - verlässlich für primitive, undefined und functions
        - null ist ein Objekt, das nicht ist.
        - NaN ist eine Number, die keine ist.
        - Arrays sind objekte
      </div>
    </div>

    <div class="step"  id="7" data-y="2000" data-x="4000">
      <h3>comparison & type conversion</h3>
      <pre><code>
'0' == 0;
''  == 0;
'' == false;
false == null;
undefined != null
// === != ==
      </code></pre>
      <div class="mod-note">
        - vergleiche in JS könne tricky sein, weil ==/!= eine ganze menge unternimmt um dem entwickler zu "helfen"
        - die regeln sind lang, teilweise kompliziert und nur wenige kennen sie wirklich.
        - ein solcher vergleich scheint praktisch wenn alle inputs strings sind. Doch sie sind Quelle mancher Fehler, und selten sinnvoll
        - ===/!== funktionert wie in == in Java: Identitätscheck.
        - in der Regel das, was wir haben wollen und erwarten
        - funktioniert auch mit primitiven typen, nicht mit Wrappern, hier ist kann ein expliziter cast sinnvoll sein.
        - Was ist der unterschied zwischen null und undefined?
        - null ist eine explizit zugewiesen referenz auf nichts.
        - undefined hat die Semantik von noch kein wert zugewiesen
        - never assign undefined! z.B. in hashes: null bedeutet der key zeigt auf nichts, während undefined heisst der key existiert nicht.
        - in den meisten fällen ist der unterschied für die Applikation jedoch unwichtig
        - Pro-Tip: someVar != null checkt ausschliesslich für null oder undefined, kürzer und eleganter, wenn die semantik in der applikation
          gleich ist, z.B. bei optionalen parametern.
      </div>
    </div>
    <div class="step"  id="8" data-y="4000" data-x="4000">
      <h3>the truth is fuzzy</h3>
      <pre><code>
var values = [true, 1, 42, -4, "nonempty", '0', {}, [],
              false, 0, NaN, null, undefined, ""];
var logStr = "At index %d, value %s is %s";

for ( var i = 0; i< values.length; i++) {

  if (values[i]) {
    console.log(logStr, i, values[i], "truthy");
  } else {
    console.log(logStr, i, values[i], "falsy");
  }
}

var optionalWithDefault = param || "default Value";
ifDef && ifDef.exec && ifDef.exec() // !!
      </code></pre>
      <div class="mod-note">
        - JavaScript interpretiert in manchen fällen alle Werte als bool-ish.
        - in einem if/for/while (wert) check und im dem ternären operator
        - in boolischen operationen
        - letzteres wird oft genutzt um kurze schreibweisen für bestimme fälle zu haben
        - || evaluiert erst den linken operanden.
          wenn das ergebnis truthy ist, ist das der lvalue, der rechte operand wird nicht evaluiert. (true || console.log('eval'))
          sonst, wird der rechte operand evaluiert und das ergebnis zurückgegeben. (false || console.log('eval'))
        - && evaluiert erst den linken operanden
          wenn das ergebnis truthy ist, wird der rechte operand evaliert und dessen ergebnis zurückgegeben (true && console.log('eval'))
          sonst wird das ergebnis des linken operanden zurückgegeben und der rechte operand nicht evaluiert
        - Achtung: beim && check wird nur truthyness und somit existenz geprüft. ob exec eine Funktion ist, wird hierdurch nicht geprüft
        - Ja, Funktionen sind Objekte und somit truthy
      </div>
    </div>
    <div class="step"  id="9" data-y="4000" data-x="6000">
      <h3>Number, cast und parsing</h3>
      <pre><code>
var num1 = 42, num2 = 3.14, num3 = 1e10;
var num4 = Number("42"), num5 = Number("1e10"),
    num6 = Number(false);
var num7 = parseInt("42"), num8 = parseInt("1e10"),
    num9 = parseInt(false);
var num10 = parseInt("0x45"), num11 = parseInt("0x45", 10);
NaN == NaN // !!
      </code></pre>
      <div class="mod-note">
        - JS numbers sind 64-bit doubles, IEEE 754 standard.
        - Operationen im Integerbereich sind genau
        - 2 wege Werte nach Number zu konvertieren: Number() und parseInt/parseFloat
        - Number wendet Regeln der Typkonversion an. Wichtig zu wissen:
          strings, die number-literale beinhalten, werden konvertieret, sonst NaN
          falsy werte werden zu 0, aber nur true wird 1
          Number Objekte zu primitiven, rest: spec lesen, in der regel NaN
        - parseInt/parseFloat parsen die strings. Der Parse-algorythmus interpretiert string anders
        - parseInt kommt mit der scientic notation nicht richtig zurecht, parseFloat schon
        - parseInt schlägt fehl wenn die zahl zu gross wird, parseFloat kommt damit klar:
          parseInt(100000000000000000000000000000000000000000000, 10) -> 1
          parseFloat liefert Infinity zurück, wenn die zahl zu groß ist.
        - Vergleiche mit NaN funktinieren nicht, NaN ist wie nichts anderes sonst. isNaN() hilft
        - Infinity == Infinity -> true auch wenn mathematisch unsinn. isFinite() ist auch da
      </div>
    </div>
    <div class="step"  id="10" data-y="2000" data-x="6000">
      <h3>Naming conventions</h3>
      <pre><code>
var allCamelCase = 42;
var IM_A_CONSTANT_WANNABE = "dont change me";
var _indicatedPrivate = "shouldn't use me from outside";
var TheConstructor = function AlsoAsFunctionName(){};
      </code></pre>
      <div class="mod-note">
        - nun ein kurzen blick auf Namenskonventionen, nun werden sie wichtig.
        - generel werden alle variablen in camel case geschrieben
        - konstanten werden in capitals mit underscores geschrieben. JavaScript beherrscht noch keine echten konstansten
        - variablen und eigenschaften, die intern/privat gemeint sind fangen mit einem _ an. JS kennt kein private wie in Java
          wir können trotzdem private properties und variablen erzeugen. wir sehen etwas später wie.
        - funktionen, die als konstruktoren zu verwenden sind, werden in camel case mit großbuchstaben verwendet. Damit soll
          an die verwendung von new erinnert werden, da ohne new das verhalten der konstruktoren anders ist, aber es gibt keinen
          direkten Fehler. es gibt jedoch techniken, die dieses verhalten verhindern und das vergessen von new abfangen.
      </div>
    </div>
    <div class="step"  id="11" data-y="0" data-x="6000">
      <h3>Recap</h3>
      questions?
      <div class="mod-note">
        pause
      </div>
    </div>
    <div class="step"  id="12" data-y="0" data-x="8000">
      <h3>Functions</h3>
      <ul>
        <li>Functions are first-class citizen</li>
        <li>Functions are special objects</li>
        <li>Functions create scope</li>
        <li>Functions return something</li>
        <li>Functions have dynamic bindings</li>
      </ul>
      <div class="mod-note">

      </div>
    </div>
    <div class="step"  id="13" data-y="2000" data-x="8000">
      <h3>Anatomy of a function</h3>
      <pre><code>
function name(explicit, params){
  var thisIsLocal = "";
  var self = this;

  return "explicit";
}
      </code></pre>
      <div class="mod-note">
      </div>
    </div>
    <div class="step"  id="14" data-y="4000" data-x="8000">
      <h3>Constructors</h3>
      <pre><code>
function Person(name, age){
  this.name = name;
  this.person = person;
}
      </code></pre>
      <div class="mod-note">
      </div>
    </div>
    <div class="step"  id="15" data-y="4000" data-x="10000">
      <h3>ways to call and this <code>this</code></h3>
      <pre><code>
someFunc(param1, param2);
obj.someMethod(param1, param2);
new SomeConstr(param1);

someFunc.apply(someThis, [param1, param2]);
someFunc.call(someThis, param1, param2);
      </code></pre>
      <div class="mod-note">
        - Ein funktion kann auf 4 arten aufgerufen werden:
          als funktion
          als methode
          als konstrutor
          und als callable function object
        - je nach aufrufart wird der implizite parameter this unterschiedlich gebunden
      </div>
    </div>
    <div class="step"  id="16" data-y="2000" data-x="10000">
      <h3>ways to call and this <code>this</code></h3>
      <pre><code>
function test(){
  console.log(typeof this);
  console.log(this);
  return this;
}

var obj = {test: test};
var forCall = {};

      </code></pre>
      <div class="mod-note">
        - Ein funktion kann auf 4 arten aufgerufen werden:
          als funktion
          als methode
          als konstrutor
          und als callable function object
        - je nach aufrufart wird der implizite parameter this unterschiedlich gebunden
        - vor allem wichtig wenn Methoden als EventListener verwendet werden.
      </div>
    </div>

    <div id="overview" class="step" data-x="3000" data-y="1500" data-scale="10">
    </div>


  </div>
<!--script src="https://raw.githubusercontent.com/bartaz/impress.js/master/js/impress.js"></script-->
<script src="impress.js"></script>
<script>impress().init();</script>

</body>
</html>
